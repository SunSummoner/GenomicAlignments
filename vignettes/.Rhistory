70.6,
61.9,
68.8,
83.8,
84.7,
75.3,
61.9,
77.1,
67.4,
69,
88,
61.2,
90.7,
71.5,
67.3,
71.3,
75.6,
65.1,
83.1,
85.7,
81,
75.5,
79.6,
68,
69.3,
76.8,
71.2,
83.8,
96.5,
60.3,
103.2,
71.1,
73.3,
73.7,
66.9,
63.2,
67.8,
66.2,
61.3,
63.7,
67.2,
77.4,
56.1,
65.1,
81.3,
79.4,
79.9,
67.4,
60.6,
64.7,
69.4,
80.1,
68.9,
65,
69.1,
71.6,
74.5,
67.6,
58.5,
75.8,
75.1,
85.1,
72.1,
95.9,
79.3,
67.6,
58.7,
64.5,
66,
64.3,
70.1,
56.1,
63,
67.8,
72.3,
57.5,
63,
78.5,
63.1,
69.6,
74.6,
83.9,
75.7,
70.4,
87.5,
73.9,
67.1,
71.7,
74.6,
70.5,
90.6,
61.6,
67.3,
72.8,
76.2,
84.7,
71.7,
65.7,
67,
66.8,
61.6,
81.9,
77.3,
70.9,
83.6,
69.1,
64.3,
80.2,
77.3,
71.8,
71,
81.5,
88.1,
76.7,
66.6,
67.8,
84.6,
72.3,
80.7,
77.7,
80.5,
64.3,
65.7,
74.6,
69.9,
82.4,
77.1,
66.6,
69.1,
65.7,
81.4,
73.9,
65.3,
65.5,
73.6,
61.7,
78,
76.8,
77.2,
96.1,
59.6,
82.5,
65,
70.1,
89.1,
68.6,
73.2,
94.5,
71.6,
72,
74.8,
69.4,
86.6,
81.5,
86.3,
71.1,
65.9,
80.8,
99.8,
70.9,
86.3,
69.9,
67.1,
76.7,
67.1,
66.3,
80,
65.9,
79.3,
58.5,
101.2,
74.3,
83.1,
91.9,
99.2,
81.5,
63.3,
68.5,
70.8,
63.3,
68.6,
80.6,
73.2,
81.9,
64.6,
84.3,
72.4,
60.3,
77,
72.9,
76.1,
68.4,
66.1,
67.1,
65.4,
94.8,
59.8,
68.2,
82.3,
74.4,
74,
84.1,
71.6,
62.9,
76.8,
63.1,
68.2,
73.5,
72,
70.8,
68.3,
89.6,
66,
73,
80.1,
83.4,
73.9,
84.3,
60.9,
69.7,
66.3,
75.2,
65.3,
89.7,
75.3,
69.3,
60.5,
74.4,
59.7,
70.8,
64.6,
58.3,
63.2,
81.9,
68.8,
66.1,
67.3,
74.6,
84.5,
68.8,
71.5,
70.4,
94.3,
76.3,
63.1,
73.7,
60.1,
59.8,
79.2,
71,
57.3,
66.2,
72.1,
73.4,
77.6,
72.4,
77,
72.2,
63.7,
72.9,
71.7,
67.8,
63.5,
85.3,
61.5,
65,
86.2,
85.1,
79.1,
72.6,
67.7,
98.6,
69
)
df <- data.frame(df)
library(ggplot2)
colnames(df) <- "CR"
gg1 <- ggplot(data = df) +
geom_histogram(mapping = aes(x = CR), fill = "skyblue") +theme_bw()
library(plotly)
install.packages("plotly")
library(plotly)
py <- plotly()
r <- py$ggplotly(gg1, session = "knitr")
devtools::install_github("ropensci/plotly")
devtools::install_github("ropensci/plotly")
devtools::install_github("ropensci/plotly")
devtools::install_github("ropensci/plotly")
devtools::install_github("ropensci/plotly")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.16")
library(GEOquery)
gds <- getGEO("GSM254626")
#for normal lungs
gsm <- getGEO(filename=system.file("extdata/GSM254626.txt.gz",package="GEOquery"))
library(GEOquery)
gds <- getGEO("GSM254626")
#for normal lungs
gsm <- getGEO(filename=system.file("extdata/GSM254626.txt.gz",package="GEOquery"))
gsmplatforms <- lapply(GSMList(gse),function(x) {Meta(x)$platform_id})
gsmlist = Filter(function(gsm) {Meta(gsm)$platform_id=='GPL96'},GSMList(gse))
Table(gds)[1:5,]
Columns(gsm)
Columns(gds)[,1:3]
gsmplatforms <- lapply(GSMList(gse),function(x) {Meta(x)$platform_id})
gse <- getGEO("GSE10072",GSEMatrix=FALSE)
gse <- getGEO("GSE10072",GSEMatrix=FALSE)
gse <- getGEO("GSE10072",GSEMatrix=FALSE)
gse <- getGEO("GSE10072",GSEMatrix=FALSE)
library(GEOquery)
gse <- getGEO("GSE10072",GSEMatrix=FALSE)
my_id <- "GSE10072"
gse <- getGEO(my_id)
gse <- gse[[1]]
gse
pData(gse)
fData(gse) ## print the gene annotation
exprs(gse)##The expression data
summary(exprs(gse))
par("mar")
par(mar=c(1,1,1,1))
exprs(gse) <- log2(exprs(gse))
boxplot(exprs(gse),outline=FALSE)
library(dplyr)
sampleInfo <- pData(gse)
sampleInfo
sampleInfo
library(pheatmap)
## argument use="c" stops an error if there are any missing data points
corMatrix <- cor(exprs(gse),use="c")
pheatmap(corMatrix)
rownames(sampleInfo)
colnames(corMatrix)
rownames(sampleInfo) <- colnames(corMatrix)
pheatmap(corMatrix,
annotation_col=sampleInfo)
library(ggplot2)
library(ggrepel)
## MAKE SURE TO TRANSPOSE THE EXPRESSION MATRIX
pca <- prcomp(t(exprs(gse)))
pheatmap(corMatrix,
+          annotation_col=sampleInfo)
pheatmap(corMatrix, annotation_col=sampleInfo)
library(pROC)
install.packages(pROC)
install.packages("pROC")
library(pROC)
library(randomForesy)
library(randomForest)
install.packages("randomForest")
library(randomForest)
set.seed(420)
num.sample <- 100
weight <- sort(rnorm(n=num.samples, mean=172, sd=29))
weight <- sort(rnorm(n=num.sample, mean=172, sd=29))
weight <- sort(rnorm(n=num.sample, mean=62, sd=11))
obese <- ifelse(test = (runif(n=num.sample)<(rank(weight)/100)), yes = 1, no = 0)
obese
plot(x=weight, y=obese)
glm.fit(obese ~ weight, family = binomial())
glm.fit(obese ~ weight, family = binomial)
glm.fit=glm(obese ~ weight, family = binomial)
lines(weight, glm.fit$fitted.values)
roc(obese, glm.fit$fitted.values, plot=TRUE)
par(pty=s)
par(pty="s")
roc(obese, glm.fit$fitted.values, plot=TRUE)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE)
roc(obese, glm.fit$fitted.values, plot=TRUE)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage")
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd+4)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=4)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=-4)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=-24)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=0)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=1)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=23)
roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2)
roc.info<-roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2)
roc.df <-data.frame(tpp=roc.info$sensitivities*100,fpp=(1-roc.info$specificities*100), thresholds=roc.info$thresholds)
head(roc.info)
tail(roc.df)
roc.df[roc.df$tpp > 60 & roc.df$tpp <80,]
roc.df[roc.df$tpp > 60 & roc.df$tpp < 80,]
roc.info<-roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2, print.auc=TRUE)
roc.info<-roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2, print.auc=TRUE, print.auc.x=45, partial.auc=c(100,90), auc.polygon = TRUE, auc.polygon.col="206")
roc.info<-roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2, print.auc=TRUE, print.auc.x=45, partial.auc=c(100,90), auc.polygon = TRUE, auc.polygon.col="20622")
rf.model <- randomForest(factor(obese) ~ weight)
roc.info<-roc(obese, glm.fit$fitted.values, plot=TRUE, legacy.axes= TRUE, percent=TRUE, xlab="False Positive Percentage", ylab="True Positive Percentage", col="234", lwd=2)
plot.roc(obese, rf.model$votes[,1], percent=TRUE, col="155", lwd=4, print.auc=TRUE, add=TRUE, print.auc.y=40)
legend("bottomright", legend=c("Logistic Regression", "Random Forest"),col=c("222","444"), lwd=4)
par(pty="m")
par(pty= "m")
legend("bottomright", legend=c("Logistic Regression", "Random Forest"),col=c("222","444"), lwd=4)
if(!require(installr)) {
install.packages("installr");
require(installr)
}
updateR()
updateR()
updateR()
updateR()
updateR()
if(!require(installr)) {
install.packages("installr");
require(installr)
}
updateR()
updateR()
install.packages("tidyclust")
install.packages("tidyclust")
install.packages("tidyclust")
install.packages("tidyclust")
install.packages("tidyclust")
install.packages("tidyclust")
install.packages("tidyclust")
pak::pak("tidymodels/tidyclust")
install.packages("pak")
pak::pak("tidymodels/tidyclust")
library(tidyclust)
set.seed(1234)
kmeans_spec <- k_means(num_clusters = 3) %>%
set_engine("stats")
kmeans_spec
kmeans_spec_fit <- kmeans_spec %>%
fit(~., data = mtcars)
kmeans_spec_fit
predict(kmeans_spec_fit, mtcars[1:4, ])
extract_cluster_assignment(kmeans_spec_fit)
extract_centroids(kmeans_spec_fit)
library(vegan)
data(varespec)
vare.dist <- vegdist(varespec, method = "jaccard")
vare
method   Dissimilarity index, partial match to "manhattan", "euclidean",
install.packages("sos")
library(sos); findFn("tanimoto jaccard")
install.packages("sfnetworks")
remotes::install_github("luukvdmeer/sfnetworks")
#' @param names A character vector containing the names that should be present
#' in the agr factor.
#'
#' @return A named factor with appropriate levels. Names are guaranteed to
#' correspond to the attribute columns of the targeted element of x and are
#' guaranteed to be sorted in the same order as those attribute columns.
#' Attribute columns do not involve the geometry list column, but do involve
#' the from and to columns.
#'
#' @noRd
make_agr_valid = function(agr, names) {
levels = c("constant", "aggregate", "identity")
if (is.null(agr)) {
valid_agr = empty_agr(names)
} else {
valid_agr = structure(agr[names], names = names, levels = levels)
}
valid_agr
}
is_null_active(active)
library(thePackage)
installed.packages("thePackage")
install.packages("thePackage")
is_null_active <- function(active){
if (is.null(active)){
active = attr(x, "active")
return(TRUE)
}
}
agr = function(x, active = NULL) {
is_null_active(active)
switch(
active,
nodes = node_agr(x),
edges = edge_agr(x),
raise_unknown_input(active)
)
}
#' @param names A character vector containing the names that should be present
#' in the agr factor.
#'
#' @return A named factor with appropriate levels. Names are guaranteed to
#' correspond to the attribute columns of the targeted element of x and are
#' guaranteed to be sorted in the same order as those attribute columns.
#' Attribute columns do not involve the geometry list column, but do involve
#' the from and to columns.
#'
#' @noRd
make_agr_valid = function(agr, names) {
levels = c("constant", "aggregate", "identity")
if (is.null(agr)) {
valid_agr = empty_agr(names)
} else {
valid_agr = structure(agr[names], names = names, levels = levels)
}
valid_agr
}
library(Rnw2Rmd)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Bioconductor/Rnw2Rmd")
pwd()
getwd()
setwd("C:\Users\DELL\Github Repositories\GenomicAlignments")
setwd("C:/Users/DELL/Github Repositories/GenomicAlignments")
list.files()
Rnw2Rmd(from = "GenomicAlignmentsIntroduction.Rnw", to = "GenomicAlignmentsIntroduction.Rmd", validate = FALSE)
library(Rnw2Rmd)
Rnw2Rmd(from = "GenomicAlignmentsIntroduction.Rnw", to = "GenomicAlignmentsIntroduction.Rmd", validate = FALSE)
setwd("C:/Users/DELL/Github Repositories/GenomicAlignments/vignettes")
Rnw2Rmd(from = "GenomicAlignmentsIntroduction.Rnw", to = "GenomicAlignmentsIntroduction.Rmd", validate = FALSE)
